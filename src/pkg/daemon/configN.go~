//Shouldn't have to care about authentication
//
package daemon

import (
	"sync"
	"os"
	"fmt"
	"syscall"
	"io/ioutil"
	"json"
)

type ConfigInfo struct {
	path      string
	lock      sync.RWMutex
	Data      map[string]string
	tmstamp   int64
	daemonLog *DaemonLogger
}

func (config *ConfigInfo) load() (err os.Error) {
	configFile, err := os.Open(config.path)
	config.daemonLog.LogError(fmt.Sprintf("ERROR: Cannot open %s for reading", config.path), err)

	intError := syscall.Flock(configFile.Fd(), 2)
	config.daemonLog.LogError("Error: Cannot read file for configurations", err)

	configContents, err := ioutil.ReadAll(configFile)
	config.daemonLog.LogError(fmt.Sprintf("ERROR: Cannot read data from %s", config.path), err)

	intError = syscall.Flock(configFile.Fd(), 8)
	if intError != 0 {
		config.daemonLog.LogError("Cannot unlock the config file for reading.", os.NewError("Flock sys call Failed"))
	}

	fi, err := configFile.Stat()
	config.daemonLog.LogError(fmt.Sprintf("ERROR: Stat of %s failed", err), err)
	err = configFile.Close()
	config.daemonLog.LogError("Cannot close file", err)

	config.lock.Lock()
	defer config.lock.Unlock()

	err = json.Unmarshal(configContents, &config.Data)
	config.daemonLog.LogError("Cannot unmarshall config.Data", err)
	config.tmstamp = fi.Mtime_ns
	return

}


func NewConfigInfo(path string, daemonLog *DaemonLogger) *ConfigInfo {
	config := new(ConfigInfo)
	config.path = path
	config.Data = make(map[string]string)
     config.daemonLog = daemonLog
     config.load()
     
	return config
}
